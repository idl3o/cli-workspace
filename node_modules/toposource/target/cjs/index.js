"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main/ts/index.ts
var ts_exports = {};
__export(ts_exports, {
  analyze: () => analyze,
  checkLoop: () => checkLoop
});
module.exports = __toCommonJS(ts_exports);

// src/main/ts/toposource.ts
var analyze = (edges, opts = { graphs: true, queue: true, check: true, strict: true }) => {
  const _edges = opts.strict ? [...edges].sort() : edges;
  const { next, prev } = getHops(_edges);
  opts.check && checkLoop(next);
  const sources = getSources(_edges);
  const graphs = opts.graphs ? getGraphs(sources, next) : void 0;
  const queue = opts.queue ? getQueue(sources, next, prev) : void 0;
  return {
    next,
    prev,
    sources,
    queue,
    graphs
  };
};
var getHops = (edges) => {
  const next = /* @__PURE__ */ new Map();
  const prev = /* @__PURE__ */ new Map();
  const pushHop = (deps, a, b) => {
    if (deps.has(a)) {
      deps.get(a).push(b);
    } else {
      deps.set(a, [b]);
    }
  };
  for (const [from, to] of edges) {
    if (to) {
      pushHop(next, from, to);
      pushHop(prev, to, from);
    }
  }
  return { next, prev };
};
var getSources = (edges) => [...new Set(edges.map(([from]) => from))].filter((node) => edges.every(([, to]) => to !== node));
var getQueue = (sources, next, prev) => {
  const nodes = /* @__PURE__ */ new Set();
  const todo = [...sources];
  const batch = /* @__PURE__ */ new Set();
  for (const [i, node] of todo.entries()) {
    if ((prev.get(node) || []).every((p) => nodes.has(p))) {
      nodes.add(node);
      pushToSet(batch, ...next.get(node) || []);
    } else {
      pushToSet(batch, node);
    }
    if (i === todo.length - 1) {
      todo.push(...batch.values());
      batch.clear();
    }
  }
  return [...nodes.values()];
};
var getGraphs = (sources, next) => {
  const graphs = [];
  for (const source of sources) {
    const nodes = mergeNested(/* @__PURE__ */ new Set([source]), next);
    const values = [...nodes.values()];
    const same = graphs.find((_graph) => [..._graph.nodes.values()].some((node) => values.includes(node)));
    if (same) {
      same.sources.push(source);
      pushToSet(same.nodes, ...values);
      continue;
    }
    graphs.push({ nodes, sources: [source] });
  }
  return graphs;
};
var checkLoop = (next) => {
  for (const [node, children] of next) {
    const desc = mergeNested(new Set(children), next);
    if (desc.has(node)) {
      throw new Error(`Loop detected: ${[node, ...desc.values()]}`);
    }
  }
};
var pushToSet = (set, ...items) => {
  for (const item of items) {
    set.add(item);
  }
  return set;
};
var mergeNested = (nodes, deps) => {
  for (const node of nodes) {
    pushToSet(nodes, ...deps.get(node) || []);
  }
  return nodes;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  analyze,
  checkLoop
});
//# sourceMappingURL=index.js.map
