{
  "version": 3,
  "sources": ["../../src/main/ts/toposource.ts"],
  "sourcesContent": ["import {\n  TAnalyze,\n  TAnalyzeOptions,\n  TDepMap,\n  TEdges,\n  TGraph\n} from './interface'\n\nexport const analyze: TAnalyze = (edges: TEdges, opts: TAnalyzeOptions = {graphs: true, queue: true, check: true, strict: true}) => {\n  const _edges = opts.strict ? [...edges].sort() : edges\n  const { next, prev } = getHops(_edges)\n  opts.check && checkLoop(next)\n\n  const sources = getSources(_edges)\n  const graphs = opts.graphs ? getGraphs(sources, next) : undefined\n  const queue = opts.queue ? getQueue(sources, next, prev) : undefined\n\n  return {\n    next,\n    prev,\n    sources,\n    queue,\n    graphs\n  } as ReturnType<TAnalyze>\n}\n\nconst getHops = (edges: TEdges): {next: TDepMap, prev: TDepMap} => {\n  const next = new Map<string, string[]>()\n  const prev = new Map<string, string[]>()\n  const pushHop = (deps: TDepMap, a: string, b: string) => {\n    if (deps.has(a)) {\n      (deps.get(a) as string[]).push(b)\n    } else {\n      deps.set(a, [b])\n    }\n  }\n\n  for (const [from, to] of edges) {\n    if (to) {\n      pushHop(next, from, to)\n      pushHop(prev, to, from)\n    }\n  }\n  return { next, prev }\n}\n\nconst getSources = (edges: TEdges): string[] => [...new Set(edges.map(([from]) => from))]\n  .filter(node => edges.every(([,to]) => to !== node))\n\nconst getQueue = (sources: string[], next: TDepMap, prev: TDepMap) => {\n  const nodes = new Set()\n  const todo = [...sources]\n  const batch: Set<string> = new Set()\n\n  for (const [i, node] of todo.entries()) {\n    if ((prev.get(node) || []).every((p) => nodes.has(p))) {\n      nodes.add(node)\n      pushToSet(batch, ...(next.get(node) || []))\n\n    } else {\n      pushToSet(batch, node)\n    }\n\n    if (i === todo.length - 1) {\n      todo.push(...batch.values())\n      batch.clear()\n    }\n  }\n\n  return [...nodes.values()]\n}\n\nconst getGraphs = (sources: string[], next: TDepMap) => {\n  const graphs: TGraph[] = []\n\n  for (const source of sources) {\n    const nodes = mergeNested(new Set([source]), next)\n    const values = [...nodes.values()]\n    const same = graphs.find(_graph => [..._graph.nodes.values()].some(node => values.includes(node)))\n\n    if (same) {\n      same.sources.push(source)\n      pushToSet(same.nodes, ...values)\n      continue\n    }\n\n    graphs.push({nodes, sources: [source]})\n  }\n\n  return graphs\n}\n\nexport const checkLoop = (next: TDepMap): void => {\n  for (const [node, children] of next) {\n    const desc = mergeNested(new Set(children), next)\n    if (desc.has(node)) {\n      throw new Error(`Loop detected: ${[node,...desc.values()]}`)\n    }\n  }\n}\n\nconst pushToSet = (set: Set<string>, ...items: string[]): Set<string> => {\n  for (const item of items) {\n    set.add(item)\n  }\n  return set\n}\n\nconst mergeNested = (nodes: Set<string>, deps: TDepMap): Set<string> => {\n  for (const node of nodes) {\n    pushToSet(nodes, ...(deps.get(node) || []))\n  }\n  return nodes\n}\n"],
  "mappings": "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",
  "names": []
}
