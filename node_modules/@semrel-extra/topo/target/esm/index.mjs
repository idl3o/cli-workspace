import{dirname as v,join as D,relative as u,resolve as k}from"path";import{promises as f}from"fs";import T from"fast-glob";import{analyze as O}from"toposource";import b from"js-yaml";var m=["dependencies","devDependencies","peerDependencies","optionalDependencies"],R=async e=>{let{pkgFilter:s}=e,t=await J(e),r=await Promise.all(t.map(o=>y(e.cwd,o)));return F(r),r.reduce((o,a)=>(s(a)&&(o[a.name]=a),o),{})},F=e=>{let s=e.map(t=>t.name).filter((t,r,o)=>o.indexOf(t)!==r);if(s.length>0)throw new Error(`Duplicated pkg names: ${s.join(", ")}`)},y=async(e,s)=>{let t=v(s),r=u(e,t)||".",o=u(e,s),a=await f.readFile(s,"utf8"),n=JSON.parse(a);return{name:n.name,manifestRaw:a,manifestPath:s,manifestRelPath:o,manifestAbsPath:s,manifest:n,path:r,relPath:r,absPath:t}},N=async(e={})=>{let{cwd:s=process.cwd(),filter:t=l=>!0,pkgFilter:r=t,depFilter:o=l=>!0,workspaces:a,workspacesExtra:n=[]}=e,i=await y(s,k(s,"package.json")),c={cwd:s,filter:t,depFilter:o,pkgFilter:r,workspacesExtra:n,workspaces:[...a||await j(i),...n]},g=await R(c),{edges:p,nodes:d}=z(Object.values(g).map(l=>l.manifest),o),{queue:I,graphs:w,next:x,prev:E,sources:h}=O([...p,...d.map(l=>[l])]);return{nodes:d,edges:p,queue:I,graphs:w,sources:h,prev:E,next:x,packages:g,root:i}},j=async e=>(Array.isArray(e.manifest.workspaces)?e.manifest.workspaces:e.manifest.workspaces?.packages)||e.manifest.bolt?.workspaces||await(async()=>{try{let s=k(e.absPath,"pnpm-workspace.yaml");return b.load(await f.readFile(s,"utf8")).packages}catch{return null}})()||[],z=(e,s,t=m)=>{let r=e.map(({name:a})=>a).sort();return{edges:e.reduce((a,n)=>{let i=new Set;return P(n,({name:c,version:g,scope:p})=>{!i.has(c)&&r.includes(c)&&s({name:c,version:g,scope:p})&&(i.add(c),a.push([c,n.name]))},t),a},[]).sort(),nodes:r}},J=async({workspaces:e,cwd:s})=>await T(e.map(t=>A(D(t,"package.json"))),{cwd:s,onlyFiles:!0,absolute:!0}),A=e=>{let s=/^\\\\\?\\/.test(e),t=/[^\u0000-\u0080]+/.test(e);return s||t?e:e.replace(/\\/g,"/")},q=async({queue:e,prev:s,cb:t})=>{let r={};return Promise.all(e.map(o=>r[o]=(async()=>{await Promise.all((s.get(o)||[]).map(a=>r[a])),await t(o)})()))},C=async({packages:e,pkg:s,scopes:t=m,cb:r})=>{let{manifest:o}=s,a=[];P(o,({name:n,version:i,scope:c,deps:g})=>{let p=e[n];p&&a.push(Promise.resolve(r({name:n,version:i,scope:c,deps:g,pkg:p,parent:s})))},t),await Promise.all(a)},P=(e,s,t=m)=>{for(let r of t){let o=e[r];if(o)for(let[a,n]of Object.entries(o))s({name:a,version:n,deps:o,scope:r})}};export{N as topo,C as traverseDeps,q as traverseQueue};
//# sourceMappingURL=index.mjs.map
