"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = load;
const typedoc_1 = require("typedoc");
const typescript_1 = require("./typescript");
const webApi_1 = require("./webApi");
const version = typedoc_1.Application.VERSION.split(/[\.-]/);
const supportsObjectReturn = +version[1] > 23 || +version[2] >= 26;
const defaultModuleSources = ["typescript", "@types/web", "@webgpu/types"];
function load(app) {
    const failed = new Set();
    app.options.addDeclaration({
        name: "resolveUtilityTypes",
        defaultValue: true,
        help: "[typedoc-plugin-mdn-links]: Resolve references to Partial, Omit, etc to the TypeScript website.",
        type: typedoc_1.ParameterType.Boolean,
    });
    app.options.addDeclaration({
        name: "additionalModuleSources",
        help: "[typedoc-plugin-mdn-links]: Additional module sources to resolve.",
        type: typedoc_1.ParameterType.Array,
        defaultValue: [],
    });
    const resolvers = [webApi_1.resolveWebApiPath];
    function resolveName(name) {
        for (const res of resolvers) {
            const result = res(name);
            if (result)
                return result;
        }
    }
    app.converter.on(typedoc_1.Converter.EVENT_BEGIN, () => {
        if (app.options.getValue("resolveUtilityTypes")) {
            resolvers.push(typescript_1.resolveTsType);
        }
    });
    app.converter.addUnknownSymbolResolver(resolveSymbol);
    function resolveSymbol(declaration, _refl, _part, symbolId) {
        if (symbolId) {
            return resolveDeclaration(makeDeclarationReference(symbolId));
        }
        return resolveDeclaration(declaration);
    }
    function resolveDeclaration(declaration) {
        const validSources = [
            ...app.options.getValue("additionalModuleSources"),
            ...defaultModuleSources,
        ];
        const moduleSource = declaration.moduleSource;
        if ((moduleSource && validSources.includes(moduleSource)) ||
            (!moduleSource && declaration.resolutionStart === "global")) {
            const names = declaration.symbolReference?.path;
            if (!names)
                return;
            const dottedName = stringifyPath(names);
            const result = resolveName(names);
            if (!result && !failed.has(dottedName)) {
                failed.add(dottedName);
                app.logger.verbose(`[typedoc-plugin-mdn-links]: Failed to resolve type: ${dottedName}`);
            }
            if (supportsObjectReturn && result) {
                return {
                    target: result,
                    caption: dottedName,
                };
            }
            return result;
        }
    }
}
function stringifyPath(path) {
    let result = path[0].path;
    for (const part of path.slice(1)) {
        result += part.navigation + part.path;
    }
    return result;
}
function makeDeclarationReference(symbolId) {
    if ("toDeclarationReference" in symbolId) {
        // Method added in TypeDoc 0.26.8, use it if present as it will be
        // smarter about package names which aren't in node_modules. Probably not
        // an issue for this project, so the simpler method is also included here.
        return symbolId.toDeclarationReference();
    }
    return {
        resolutionStart: "global",
        moduleSource: getModuleName(symbolId.fileName),
        symbolReference: getSymbolReference(symbolId.qualifiedName),
    };
}
function getModuleName(symbolPath) {
    // Attempt to decide package name from path if it contains "node_modules"
    let startIndex = symbolPath.lastIndexOf("node_modules/");
    if (startIndex !== -1) {
        startIndex += "node_modules/".length;
        let stopIndex = symbolPath.indexOf("/", startIndex);
        // Scoped package, e.g. `@types/node`
        if (symbolPath[startIndex] === "@") {
            stopIndex = symbolPath.indexOf("/", stopIndex + 1);
        }
        return symbolPath.substring(startIndex, stopIndex);
    }
}
function getSymbolReference(qualifiedName) {
    return {
        path: (0, typedoc_1.splitUnquotedString)(qualifiedName, ".").map((path) => ({
            navigation: ".",
            path,
        })),
    };
}
