"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalImportSubstituter = void 0;
const path = __importStar(require("path"));
class ExportResolver {
    constructor(packageName, packageMain, packageExports) {
        if (!packageMain && !packageExports) {
            throw new Error("Failed to find a valid main or exports entry in package.json file");
        }
        this.packageName = packageName;
        this.packageMain = packageMain;
        this.packageExports = packageExports;
    }
    findMatchingExport(path = ".") {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!this.packageExports) {
            throw new Error("No exports defined in package.json");
        }
        if (typeof this.packageExports === "string" && path === ".") {
            return this.packageExports;
        }
        const conditionalExports = this.packageExports;
        const conditionalExportEntry = (_d = (_c = (_b = (_a = conditionalExports["node-addons"]) !== null && _a !== void 0 ? _a : conditionalExports.node) !== null && _b !== void 0 ? _b : conditionalExports.import) !== null && _c !== void 0 ? _c : conditionalExports.require) !== null && _d !== void 0 ? _d : conditionalExports.default;
        if (conditionalExportEntry && path === ".") {
            return conditionalExportEntry;
        }
        const subpathExports = this.packageExports;
        const lookupPath = path === "." ? path : `.${path}`;
        const [matchingExportPath, matchingSubpath] = (_e = Object.entries(subpathExports).find(([exportedPath]) => {
            if (lookupPath === exportedPath) {
                return true;
            }
            const [prefix, suffix] = exportedPath.split("*");
            return (exportedPath.includes("*") &&
                lookupPath.startsWith(prefix) &&
                lookupPath.endsWith(suffix || ""));
        })) !== null && _e !== void 0 ? _e : [];
        if (!matchingExportPath || !matchingSubpath) {
            throw new Error(`Unable to resolve export for path "${this.packageName}${path === "." ? "" : path}"`);
        }
        const [exportPrefix, exportSuffix = ""] = matchingExportPath.split("*");
        const internalPath = lookupPath.substring(exportPrefix.length, lookupPath.length - exportSuffix.length);
        const subpathEntry = typeof matchingSubpath === "string"
            ? matchingSubpath
            : ((_j = (_h = (_g = (_f = matchingSubpath["node-addons"]) !== null && _f !== void 0 ? _f : matchingSubpath.node) !== null && _g !== void 0 ? _g : matchingSubpath.import) !== null && _h !== void 0 ? _h : matchingSubpath.require) !== null && _j !== void 0 ? _j : matchingSubpath.default);
        if (subpathEntry) {
            const [internalPrefix, internalSuffix = ""] = subpathEntry.split("*");
            return `${internalPrefix}${internalPath}${internalSuffix}`;
        }
        throw new Error(`Unable to resolve export for path "${this.packageName}${path === "." ? "" : path}"`);
    }
    stripSuffix(filePath) {
        return filePath.replace(/\.(tsx?|js)$/, "");
    }
    resolveExportPath(path) {
        if (!this.packageExports) {
            if (!this.packageMain) {
                throw new Error("Failed to find main or exports entry in package.json");
            }
            return path !== null && path !== void 0 ? path : this.stripSuffix(this.packageMain);
        }
        const matchingExport = this.findMatchingExport(path);
        return this.stripSuffix(matchingExport);
    }
}
class LocalImportSubstituter {
    constructor(packageDefinition) {
        this.packageName = packageDefinition.name;
        this.packageRoot = packageDefinition.packageRoot;
        this.exportResolver = new ExportResolver(packageDefinition.name, packageDefinition.main, packageDefinition.exports);
    }
    substituteLocalPackageImports(code) {
        const escapedPackageName = this.packageName.replace(/\\/g, "\\/");
        const projectImportRegex = new RegExp(`('|")(?:${escapedPackageName})(/[^'"]+)?('|"|)`);
        const codeLines = code.split("\n");
        const localisedLines = codeLines.map((line) => {
            if (!line.trim().startsWith("import ")) {
                return line;
            }
            const match = projectImportRegex.exec(line);
            if (!match) {
                return line;
            }
            const { 1: openQuote, 2: subPath, 3: closeQuote, index } = match;
            const prefix = line.substring(0, index);
            const resolvedExportPath = this.exportResolver.resolveExportPath(subPath);
            const fullExportPath = path
                .join(this.packageRoot, resolvedExportPath)
                .replace(/\\/g, "\\\\");
            return `${prefix}${openQuote}${fullExportPath}${closeQuote}`;
        });
        return localisedLines.join("\n");
    }
}
exports.LocalImportSubstituter = LocalImportSubstituter;
//# sourceMappingURL=LocalImportSubstituter.js.map